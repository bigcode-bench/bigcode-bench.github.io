<!doctype html>
<html>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100;400&display=swap" rel="stylesheet" />

<head>
    <meta charset="UTF-8" />
    <title>BigCodeBench Leaderboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.3.3/dist/echarts.min.js"></script>
    <link rel="icon"
        href="https://cdn-avatars.huggingface.co/v1/production/uploads/1659521200179-5e48005437cb5b49818287a5.png" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" />

    <style>
        body {
            font-family: "JetBrains Mono", monospace;
            background-color: #ffffff;
            color: #000000;
        }

        #content {
            width: 75%;
        }

        th,
        td {
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        #notes {
            font-size: 1em;
        }

        #notes h3 {
            margin-top: 1em;
            font-size: 2em;
            text-align: center;
        }

        #notes li {
            font-size: 1.2em;
            font-weight: 300;
            margin: 1em;
        }

        .form-select {
            font-size: 1em;
        }

        table {
            table-layout: auto;
            width: 100%;
        }

        @media screen and (max-width: 1400px) {
            body {
                font-size: 1.6vw;
            }

            #content {
                width: 100%;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.6em;
            }

            h3 {
                font-size: 1.2em;
            }

            table {
                font-size: medium;
            }
        }
        /* Add this to your existing <style> section */
          .btn-group-lg > .btn, .btn-lg {
              padding: 0.5rem 1rem;
              font-size: 1.25rem;
              border-radius: 0.3rem;
          }
      
          .btn-outline-hard {
              color: #ff6b6b;
              border: 2px solid #ff6b6b;
              background-color: transparent;
          }
      
          .btn-outline-hard:hover,
          .btn-check:checked + .btn-outline-hard,
          .btn-outline-hard:active {
              color: #fff;
              background-color: #ff6b6b !important;
              border-color: #ff6b6b;
          }
      
          .btn-outline-full {
              color: #4ecdc4;
              border: 2px solid #4ecdc4;
              background-color: transparent;
          }
      
          .btn-outline-full:hover,
          .btn-check:checked + .btn-outline-full,
          .btn-outline-full:active {
              color: #fff;
              background-color: #4ecdc4 !important;
              border-color: #4ecdc4;
          }
    </style>
</head>

<body>
    <div id="content" class="container-fluid d-flex flex-column align-items-center gap-3">
        <h1 class="text-nowrap mt-5">üå∏ BigCodeBench Leaderboard</h1>
        <div class="alert alert-info border border-info p-4 text-center" style="background-color: #f8f9fa; max-width: 800px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <p class="mb-0 fw-bold" style="font-size: 1.3em;">
                üéâ Check out our latest work
                <br> 
                <a href="https://swe-arena.com" class="fw-bolder text-decoration-none"><u>SWE Arena</u></a>
                <br>
                Open Evaluation Platform on AI for Software Engineering,
                <br>
                featuring real-time code execution for any programs!
            </p>
        </div>
        <h3 class="fw-light text-nowrap">
            <small id="warning">BigCodeBench evaluates LLMs with <strong><u>practical</u></strong> and
                <strong><u>challenging</u></strong> programming tasks.<br /></small>
        </h3>
        <!-- <div class="d-flex flex-row justify-content-center gap-3">
            <a href="https://github.com/bigcode-project/bigcodebench"><img
                    src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white"
                    alt="github" class="img-fluid" /></a>
            <a href="https://huggingface.co/spaces/bigcode/bigcodebench-leaderboard"><img
                    src="https://img.shields.io/badge/huggingface-ü§ó_Leaderboard-yellow.svg?style=for-the-badge"
                    alt="leaderboard" class="img-fluid" /></a>
            <a href="https://arxiv.org/abs/2406.15877"><img
                    src="https://img.shields.io/badge/arXiv-2406.15877-b31b1b.svg?style=for-the-badge" alt="paper"
                    class="img-fluid" /></a>
            <a href="https://huggingface.co/blog/terryyz/bigcodebench-hard"><img
                    src="https://img.shields.io/badge/Blog-Hard-orange.svg?style=for-the-badge" alt="paper"
                    class="img-fluid" /></a>
        </div> -->
        <div class="btn-group btn-group-lg" role="group" id="Subset" style="margin-bottom: 10px;">
          <input type="radio" class="btn-check" name="subsetRadio" id="Hard" checked />
          <label class="btn btn-outline-hard" for="Hard">Hard</label>
          <input type="radio" class="btn-check" name="subsetRadio" id="Full" />
          <label class="btn btn-outline-full" for="Full">Full</label>
      </div>
        <div class="btn-group" role="group" id="Benchmark">
          <input type="radio" class="btn-check" name="btnradio" id="Complete" />
          <label class="btn btn-outline-primary" for="Complete">Complete</label>
          <input type="radio" class="btn-check" name="btnradio" id="Instruct" />
          <label class="btn btn-outline-primary" for="Instruct">Instruct</label>
          <input type="radio" class="btn-check" name="btnradio" id="Average" checked />
          <label class="btn btn-outline-primary" for="Average">Average</label>
      </div>
        <div class="btn-group" role="group" id="ViewType" style="margin-left: 10px;">
          <input type="radio" class="btn-check" name="viewType" id="SizeView" checked />
          <label class="btn btn-outline-secondary" for="SizeView">Size View</label>
          <input type="radio" class="btn-check" name="viewType" id="TimeView" />
          <label class="btn btn-outline-secondary" for="TimeView">Time View</label>
        </div>
        <div class="form-check form-switch mt-3">
            <input class="form-check-input" type="checkbox" id="toggleUnknownSize">
            <label class="form-check-label" for="toggleUnknownSize">Show Models with Unknown Sizes</label>
        </div>
        <div id="chart" style="width: 100%; height: 600px"></div>
        <div class="container-fluid d-flex flex-row flex-nowrap">
            <div class="container-fluid d-flex flex-column align-items-center">
                <table id="origin" class="table table-responsive table-striped table-bordered flex-shrink-1 border border-3"></table>
            </div>
        </div>
        <div id="notes">
            <h3>üìù Notes</h3>
            <div class="inline-block mt-3">
                <ol>
                    <li>
                        Evaluated using
                        <a href="https://github.com/bigcode-project/bigcodebench-annotation/releases/tag/v0.1.0">BigCodeBench</a>;
                    </li>
                    <li>
                        Hard Set vs Full Set:
                        <br />
                        <strong>Hard Set</strong>: A subset of ~150 BigCodeBench tasks which is more user-facing and challenging.
                        <br />
                        <strong>Full Set</strong>: The full set of 1140 BigCodeBench tasks.
                    </li>
                    <li>
                        Models are ranked according to (calibrated) Pass@1 using greedy decoding. Setup details can be
                        found
                        <a href="https://github.com/bigcode-project/bigcodebench/blob/main/bigcodebench/generate.py">here</a>.
                    </li>
                    <li>
                        <i>Complete</i> vs <i>Instruct</i>:
                        <br />
                        <i><strong><u>Complete</u></strong></i>: Code Completion based on the structured long-context
                        docstring. This variant tests if the models are good at coding.
                        <br />
                        <strong><i><u>Instruct</u></i> (üî•Vibe Checküî•)</strong>: Code Generation based on the brief NL-oriented instructions. This variant tests if the models are really capable enough to
                        understand human intents to code.
                    </li>
                    <li>
                        Wonder the relative performance among models, or the current progress of task solve rate? Check
                        out the <u><a href="https://huggingface.co/spaces/bigcode/bigcodebench-leaderboard">ü§ó Hugging
                                Face Leaderboard</a></u>!
                    </li>
                    <li>
                        üí§ indicates the models having at least a difference of 1% between the calibrated Pass@1 and the
                        original one. What does this imply? Instruction-tuned models <u><a
                                href="https://community.openai.com/t/why-i-think-gpt-is-now-lazy">can be
                                lazy</a></u>, omitting essential code parts and thus failing on some tasks.
                        Therefore, we add the missing parts during evaluation, and report the calibrated Pass@1 score as
                        default,
                    <li>
                        ‚ú® marks models evaluated using a chat setting, while others perform direct code completion. We
                        note that some instruction-tuned models miss the chat template in their tokenizer configuration.
                    </li>
                    <li>
                        Model providers have the responsibility to avoid data contamination. Models trained on close data
                        can be affected by contamination.
                    </li>
                    <li>
                        üíö means open weights and open data. üíô means open weights and open SFT data, but the base model
                        is not data-open. What does this imply? üíöüíô models open-source the data such that one can
                        concretely reason about contamination.
                    </li>
                    <li>
                        "Size" here is the number of model parameters during inference.
                    </li>
                </ol>
            </div>
        </div>
        <div id="notes">
            <h3>ü§ó More Leaderboards</h3>
            In addition to BigCodeBench leaderboards, it is recommended to comprehensively understand LLM coding ability
            through a diverse set of benchmarks and leaderboards, such as:
            <div class="inline-block mt-3">
                <ol>
                    <li>
                        <a href="https://swe-arena.com/">SWE Arena</a>
                    </li>
                    <li>
                        <a href="https://evalplus.github.io/leaderboard.html">EvalPlus Leaderboard</a>
                    </li>
                    <li>
                            <a href="https://spider2-sql.github.io">Spider 2.0</a>
                    </li>
                    <li>
                        <a href="https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard">BigCodeBench Leaderboard</a>
                    </li>
                    <li>
                        <a href="https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard">Chatbot Arena
                            Leaderboard</a>
                    </li>
                    <li>
                        <a href="https://github.com/amazon-science/cceval">CrossCodeEval</a>
                    </li>
                    <li>
                        <a href="https://fudanselab-classeval.github.io/">ClassEval</a>
                    </li>
                    <li>
                        <a href="https://crux-eval.github.io/leaderboard.html">CRUXEval</a>
                    </li>
                    <li>
                        <a href="https://codetlingua.github.io/leaderboard.html">Code Lingua</a>
                    </li>
                    <li><a href="https://evo-eval.github.io/">Evo-Eval</a></li>
                    <li>
                        <a href="https://github.com/01-ai/HumanEval.jl">HumanEval.jl - Julia version HumanEval with
                            EvalPlus test cases</a>
                    </li>
                    <li>
                        <a href="https://infi-coder.github.io/inficoder-eval/">InfiCoder-Eval</a>
                    </li>
                    <li>
                        <a href="https://livecodebench.github.io/leaderboard.html">LiveCodeBench</a>
                    </li>
                    <li>
                        <a href="https://github.com/THUDM/NaturalCodeBench">NaturalCodeBench</a>
                    </li>
                    <li><a href="https://github.com/Leolty/repobench">RepoBench</a></li>
                    <li><a href="https://www.swebench.com/">SWE-bench</a></li>
                    <li>
                        <a href="https://leaderboard.tabbyml.com/">TabbyML Leaderboard</a>
                    </li>
                    <li>
                        <a href="https://github.com/alphadl/OOP-eval">OOP</a>
                    </li>
                </ol>
            </div>
        </div>

        <div id="notes">
            <h3>üôè Acknowledgements</h3>
            <div class="inline-block mt-3">
                <ul>
                    <li>
                        We thank the EvalPlus team for providing the leaderboard template.
                    </li>
                    <li>
                        We are grateful for the significant contributions from the BigCode community.
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const originTable = document.getElementById("origin");
        const benchmarkRadio = document.getElementById("Benchmark");
        const chartDom = document.getElementById("chart");
        const toggleUnknownSize = document.getElementById("toggleUnknownSize");
        const sizeViewRadio = document.getElementById("SizeView");
        const timeViewRadio = document.getElementById("TimeView");
        var chart = echarts.init(chartDom);

        var dataUrl = "results-hard.json"; // Default data source
        var globalData;
        var currentSplit = "average"; // Track current split
        var currentView = "size"; // Track current view type (size or time)

        // Function to load data based on the selected subset
        function loadData() {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", dataUrl, true);
          xhr.onload = function() {
              if (xhr.status === 200) {
                  globalData = JSON.parse(xhr.responseText);
                  globalData = Object.keys(globalData).map((key) => ({
                      Model: key,
                      ...globalData[key],
                      "pass@1": {
                          ...globalData[key]["pass@1"],
                          "average": calcAverage(globalData[key]["pass@1"]["complete"], globalData[key]["pass@1"]["instruct"])
                      }
                  }));
                  
                  // Reset chart data before displaying new data
                  resetChartData();
                  
                  displayTable(originTable, currentSplit);
                  if (currentView === "size") {
                      displayChart(currentSplit, toggleUnknownSize.checked);
                  } else {
                      displayTimeChart(currentSplit, toggleUnknownSize.checked);
                  }
              } else {
                  alert("Failed to load data from " + dataUrl);
              }
          };
          xhr.send();
      }

        // Event listeners for the subset radio buttons
        document.getElementById("Hard").addEventListener("change", function () {
            if (this.checked) {
                dataUrl = "results-hard.json";
                loadData();
            }
        });

        document.getElementById("Full").addEventListener("change", function () {
            if (this.checked) {
                dataUrl = "results.json";
                loadData();
            }
        });

        // Event listeners for view type radio buttons
        sizeViewRadio.addEventListener("change", function() {
            if (this.checked) {
                currentView = "size";
                resetChartData();
                displayChart(currentSplit, toggleUnknownSize.checked);
            }
        });

        timeViewRadio.addEventListener("change", function() {
            if (this.checked) {
                currentView = "time";
                resetChartData();
                displayTimeChart(currentSplit, toggleUnknownSize.checked);
            }
        });

        // Initial data load
        loadData();

        // Function to create a visual performance bar for the tooltip
        const createPerformanceBar = (score) => {
            const maxWidth = 100;
            const width = Math.min(maxWidth, score);
            const color = score > 50 ? '#4caf50' : score > 30 ? '#ff9800' : '#f44336';
            
            return `<div style="margin-top:3px;">Performance: 
                   <div style="display:inline-block;background:#eee;width:${maxWidth}px;height:10px;">
                     <div style="background:${color};height:10px;width:${width}px;"></div>
                   </div>
                 </div>`;
        };

        const calcAverage = (a, b) => {
            if (a == null || b == null) {
                return null;
            } else {
                return parseFloat(((parseFloat(a) + parseFloat(b)) / 2).toFixed(1));
            }
        };

        const clearTable = () => {
            originTable.innerHTML = "";
        };

        const clearChart = () => {
            chartOption.xAxis.data = [];
            chartOption.series[0].data = [];
            chartOption.series[1].data = [];
            chartOption.series[0].markLine.data = [];
            chartOption.series[1].markLine.data = [];
        };

        const resetChartData = () => {
            // Reset all chart data structures
            chartOption.xAxis.data = [];
            chartOption.series[0].data = [];
            chartOption.series[1].data = [];
            chartOption.series[0].markLine.data = [];
            chartOption.series[1].markLine.data = [];
            chart.setOption(chartOption, true); // Force chart refresh
        };

        var chartOption = {
            legend: {
                data: ["pass@1*"],
            },
            grid: {
                left: "1%",
                right: "4%",
                bottom: "3%",
                containLabel: true,
            },
            xAxis: {
                name: "Size",
                type: "category",
                boundaryGap: false,
                data: [],
                axisLabel: {
                    formatter: function (value) {
                        return value + "B";
                    },
                },
            },
            yAxis: {
                name: "PASS@1 (greedy decoding)",
                type: "value",
                show: true,
                nameTextStyle: {
                    align: "left",
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: "gray",
                        type: "dashed",
                    },
                },
            },
            legend: {
                data: ["base", "instructed"],
                itemStyle: {
                    opacity: 1.0,
                },
            },
            tooltip: {
                trigger: "item",
                formatter: function(params) {
                    return params.data.name + '<br/>' + 
                           'Date: ' + params.data.date + '<br/>' +
                           'Score: ' + params.data.value[1] + '<br/>' +
                           'Size: ' + (params.data.size ? params.data.size + 'B' : 'Unknown');
                },
                axisPointer: {
                    type: "cross",
                },
            },
            series: [
                {
                    name: "base",
                    type: "scatter",
                    data: [],
                    itemStyle: {
                        color: "#91cc75",
                        opacity: 0.2,
                    },
                    emphasis: {
                        focus: "series",
                    },
                    lineStyle: {
                        width: 2,
                    },
                    markLine: {
                        symbol: "none",
                        emphasis: {
                            label: {
                                position: "middle",
                                formatter: function (params) {
                                    return params.data.name;
                                },
                            },
                        },
                        data: [],
                    },
                },
                {
                    name: "instructed",
                    type: "scatter",
                    data: [],
                    itemStyle: {
                        color: "#5470c6",
                        opacity: 0.2,
                    },
                    emphasis: {
                        focus: "series",
                    },
                    lineStyle: {
                        width: 2,
                    },
                    markLine: {
                        symbol: "none",
                        emphasis: {
                            label: {
                                position: "middle",
                                formatter: function (params) {
                                    return params.data.name;
                                },
                            },
                        },
                        data: [],
                    },
                },
            ],
        };

        // Time chart option
        var timeChartOption = {
            grid: {
                left: "1%",
                right: "4%",
                bottom: "3%",
                containLabel: true,
            },
            xAxis: {
                name: "Time",
                type: "category",
                data: [],
                axisLabel: {
                    formatter: function (value) {
                        return value;
                    },
                    interval: 0,
                    rotate: 30,
                    margin: 15
                },
            },
            yAxis: {
                name: "PASS@1 (greedy decoding)",
                type: "value",
                show: true,
                nameTextStyle: {
                    align: "left",
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: "gray",
                        type: "dashed",
                    },
                },
            },
            legend: {
                data: ["base", "instructed"],
                itemStyle: {
                    opacity: 1.0,
                },
            },
            tooltip: {
                trigger: "item",
                formatter: function(params) {
                    return params.data.name + '<br/>' + 
                           'Date: ' + params.data.date + '<br/>' +
                           'Score: ' + params.data.value[1] + '<br/>' +
                           'Size: ' + (params.data.size ? params.data.size + 'B' : 'Unknown');
                },
                axisPointer: {
                    type: "cross",
                },
            },
            series: [
                {
                    name: "base",
                    type: "scatter",
                    data: [],
                    symbolSize: function(data) {
                        // Scale symbol size based on model size
                        return data[2] ? Math.max(5, Math.min(20, data[2] * 1.5)) : 7;
                    },
                    itemStyle: {
                        color: "#91cc75",
                        opacity: 0.5,
                    },
                    emphasis: {
                        focus: "series",
                    },
                },
                {
                    name: "instructed",
                    type: "scatter",
                    data: [],
                    symbolSize: function(data) {
                        // Scale symbol size based on model size
                        return data[2] ? Math.max(5, Math.min(20, data[2] * 1.5)) : 7;
                    },
                    itemStyle: {
                        color: "#5470c6",
                        opacity: 0.5,
                    },
                    emphasis: {
                        focus: "series",
                    },
                },
            ],
        };

        const theaders = ["Model", "Pass@1"];

        // score: 'complete', 'instruct', 'average'
        const displayTable = (table, score) => {
          // Clear existing table content
          table.innerHTML = '';
      
          // Filter out Null and sort data
          const data = globalData
              .filter((row) => row["pass@1"][score] != null)
              .sort((a, b) => b["pass@1"][score] - a["pass@1"][score]);
      
          // Create table header
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          
          // Add rank header
          const rankHeader = document.createElement("th");
          rankHeader.textContent = "#";
          headerRow.appendChild(rankHeader);
          
          // Add other headers
          theaders.forEach(function (header) {
              const th = document.createElement("th");
              th.textContent = header;
              if (header == "Pass@1") {
                  th.style.backgroundColor = "#EEFFEE";
              }
              headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
      
          // Create table body
          const tbody = document.createElement("tbody");
          let previousScore = null;
          let actualRank = 1;
      
          data.forEach((row, index) => {
              const dataRow = document.createElement("tr");
              const rankCell = document.createElement("td");
      
              if (row["pass@1"][score] !== previousScore) {
                  actualRank = index + 1;
                  previousScore = row["pass@1"][score];
              }
      
              rankCell.textContent = actualRank;
              dataRow.appendChild(rankCell);
      
              const modelCell = document.createElement("td");
              modelCell.textContent = actualRank <= 3 ? ["ü•á ", "ü•à ", "ü•â "][actualRank - 1] : "";
      
              const modelLink = document.createElement("a");
              modelLink.href = row["link"];
              modelLink.textContent = row["Model"];
              modelLink.classList.add("link-underline-primary", "text-nowrap");
              modelCell.appendChild(modelLink);
              modelCell.classList.add("d-flex", "flex-nowrap");
      
              if (row["prompted"]) {
                  const promptedSymbol = document.createElement("span");
                  promptedSymbol.textContent = "‚ú®";
                  modelCell.appendChild(promptedSymbol);
              }
      
              // Add open-data and lazy symbols here if needed
      
              dataRow.appendChild(modelCell);
      
              const passCell = document.createElement("td");
              passCell.classList.add("text-nowrap");
              passCell.textContent = row["pass@1"][score] + (row["lazy"] ? "üí§" : "");
              passCell.style.backgroundColor = "#EEFFEE";
              passCell.style.fontWeight = "bold";
              dataRow.appendChild(passCell);
      
              tbody.appendChild(dataRow);
          });
      
          table.appendChild(tbody);
      };

        // Function to clean model names by removing parenthetical parts
        const cleanModelName = (name) => {
            // Remove anything in parentheses at the end of the name
            return name.replace(/\s*\([^)]*\)\s*$/, '');
        };

        const displayChart = (score, showUnknownSize = true) => {
            // Reset chart data at the start
            resetChartData();
            
            // sort first
            let data = globalData
                .filter((model) => {
                    return model["pass@1"][score] != null;
                })
                .sort((a, b) => {
                    return b["pass@1"][score] - a["pass@1"][score];
                });

            if (!showUnknownSize) {
                data = data.filter((model) => model["size"] != null);
            }

            const sizeList = [
                ...new Set(
                    data
                    .filter((model) => model["size"] != null)
                    .map((model) => Math.round(model["size"])),
                ),
            ].sort((a, b) => {
                return a - b;
            });

            chartOption.xAxis.data = sizeList;
            chartOption.yAxis.max =
                1 + Math.max(...data.map((model) => model["pass@1"][score]));

            const nonPromptedModels = data.filter(
                (model) => model["prompted"] == false,
            );
            const promptedModels = data.filter(
                (model) => model["prompted"] == true,
            );

            [nonPromptedModels, promptedModels].forEach((series, idx) => {
                series.forEach((model) => {
                    if (model["size"] == null) {
                        chartOption.series[idx].markLine.data.push({
                            name: model["Model"],
                            yAxis: model["pass@1"][score],
                        });
                    } else {
                        chartOption.series[idx].data.push({
                            name: model["Model"],
                            value: [`${Math.round(model["size"])}`, model["pass@1"][score]],
                        });
                    }
                });
            });

            const offsets = [
                    [50, 0]
                ]
                .concat(Array.from({
                    length: sizeList.length - 2
                }, () => [0, 0]))
                .concat([
                    [-50, 0]
                ]);
            sizeList.forEach((size, idx) => {
                const bestNonPromptedModel = nonPromptedModels
                    .filter((model) => Math.round(model["size"]) == size)
                    .sort((a, b) => {
                        return b["pass@1"][score] - a["pass@1"][score];
                    })[0];
                const bestPromptedModel = promptedModels
                    .filter((model) => Math.round(model["size"]) == size)
                    .sort((a, b) => {
                        return b["pass@1"][score] - a["pass@1"][score];
                    })[0];
                const hightLightBest = (series, model) => {
                    const point = chartOption.series[series].data.find(
                        (point) => point.name == model["Model"],
                    );
                    point.itemStyle = {
                        opacity: 1.0,
                    };
                    point.label = {
                        show: true,
                        position: "top",
                        offset: offsets[idx],
                        formatter: function (params) {
                            return cleanModelName(params.data.name);
                        },
                        color: "inherit",
                        opacity: 1.0  // Ensure label is fully opaque
                    };
                };
                if (bestNonPromptedModel) {
                    hightLightBest(0, bestNonPromptedModel);
                }
                if (bestPromptedModel) {
                    hightLightBest(1, bestPromptedModel);
                }
            });

            chart.setOption(chartOption);
        };

        // Function to display time-based chart
        const displayTimeChart = (score, showUnknownSize = true) => {
            // Create a new chart option for time view
            const timeOption = JSON.parse(JSON.stringify(timeChartOption));
            
            // Update tooltip formatter
            timeOption.tooltip.formatter = function(params) {
                return params.data.name + '<br/>' + 
                       'Date: ' + params.data.date + '<br/>' +
                       'Score: ' + params.data.value[1] + '<br/>' +
                       'Size: ' + (params.data.size ? params.data.size + 'B' : 'Unknown');
            };
            
            // Filter and sort data
            let data = globalData
                .filter((model) => {
                    return model["pass@1"][score] != null && model["date"] != null;
                })
                .sort((a, b) => {
                    return new Date(a["date"]) - new Date(b["date"]);
                });

            if (!showUnknownSize) {
                data = data.filter((model) => model["size"] != null);
            }

            // Group dates by two-month periods
            const dateGroups = {};
            data.forEach(model => {
                const date = new Date(model.date);
                const year = date.getFullYear();
                // Group by pairs of months (0-1, 2-3, 4-5, 6-7, 8-9, 10-11)
                const twoMonthPeriod = Math.floor(date.getMonth() / 2);
                const yearPeriod = `${year}-${String(twoMonthPeriod).padStart(1, '0')}`;
                if (!dateGroups[yearPeriod]) {
                    dateGroups[yearPeriod] = [];
                }
                dateGroups[yearPeriod].push(model);
            });

            // Create x-axis labels (dates) with formatted display names
            const dateLabels = Object.keys(dateGroups).sort();
            timeOption.xAxis.data = dateLabels.map(period => {
                const [year, twoMonthNum] = period.split('-');
                const startMonth = parseInt(twoMonthNum) * 2;
                const endMonth = startMonth + 1;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${monthNames[startMonth]}-${monthNames[endMonth]} ${year}`;
            });

            // Set y-axis max
            timeOption.yAxis.max = Math.ceil(Math.max(...data.map((model) => model["pass@1"][score])) * 1.1);

            // Separate models by prompted status
            const nonPromptedModels = data.filter(model => model["prompted"] == false);
            const promptedModels = data.filter(model => model["prompted"] == true);

            // Function to find top model for each date group
            const findTopModels = (models, dateGroup) => {
                return models
                    .filter(model => {
                        const date = new Date(model.date);
                        const yearPeriod = `${date.getFullYear()}-${String(Math.floor(date.getMonth() / 2)).padStart(1, '0')}`;
                        return yearPeriod === dateGroup;
                    })
                    .sort((a, b) => b["pass@1"][score] - a["pass@1"][score]);
            };

            // Function to calculate symbol size based on model size (logarithmic scale)
            const calculateSymbolSize = (size) => {
                if (size === null || size === undefined) {
                    // This will be updated with the max size after we process all models
                    return 0;
                }
                // Use logarithmic scale with base multiplier for better size distinction
                return 5 + Math.log2(size) * 8;
            };

            // Find the largest known model size for setting unknown model sizes
            const maxModelSize = Math.max(...data
                .filter(model => model.size !== null && model.size !== undefined)
                .map(model => calculateSymbolSize(model.size)));

            // Create series for unknown size models (to be rendered first/bottom)
            const unknownSizeBaseSeries = {
                name: "base (unknown size)",
                type: "scatter",
                data: [],
                showInLegend: false,
                symbolSize: function(data) {
                    return maxModelSize * 0.8; // Make unknown size models slightly smaller
                },
                itemStyle: {
                    color: "#ff0000",
                    opacity: 0.2
                },
                emphasis: {
                    focus: "series",
                }
            };
            
            const unknownSizeInstructedSeries = {
                name: "instructed (unknown size)",
                type: "scatter",
                data: [],
                showInLegend: false,
                symbolSize: function(data) {
                    return maxModelSize * 0.8; // Make unknown size models slightly smaller
                },
                itemStyle: {
                    color: "#ff0000",
                    opacity: 0.2
                },
                emphasis: {
                    focus: "series",
                }
            };
            
            // Create series for known size models (to be rendered last/top)
            const knownSizeBaseSeries = {
                name: "base",
                type: "scatter",
                data: [],
                symbolSize: function(data) {
                    return calculateSymbolSize(data[2]);
                },
                itemStyle: {
                    color: "#91cc75",
                    opacity: 0.2
                },
                emphasis: {
                    focus: "series",
                }
            };
            
            const knownSizeInstructedSeries = {
                name: "instructed",
                type: "scatter",
                data: [],
                symbolSize: function(data) {
                    return calculateSymbolSize(data[2]);
                },
                itemStyle: {
                    color: "#5470c6",
                    opacity: 0.2
                },
                emphasis: {
                    focus: "series",
                }
            };

            // Add data points to appropriate series based on known/unknown size
            [nonPromptedModels, promptedModels].forEach((seriesModels, seriesIdx) => {
                dateLabels.forEach((dateGroup, dateIdx) => {
                    const modelsInGroup = findTopModels(seriesModels, dateGroup);
                    
                    // Add all models in the group
                    modelsInGroup.forEach((model, modelIdx) => {
                        const date = new Date(model.date);
                        const yearPeriod = `${date.getFullYear()}-${String(Math.floor(date.getMonth() / 2)).padStart(1, '0')}`;
                        const xIndex = dateLabels.indexOf(yearPeriod);
                        
                        // Create data point
                        const dataPoint = {
                            name: model.Model,
                            date: model.date,
                            size: model.size,
                            value: [xIndex, model["pass@1"][score], model.size || 0]
                        };
                        
                        // Add to appropriate series based on known/unknown size
                        if (model.size === null || model.size === undefined) {
                            // Unknown size models
                            if (seriesIdx === 0) {
                                unknownSizeBaseSeries.data.push(dataPoint);
                            } else {
                                unknownSizeInstructedSeries.data.push(dataPoint);
                            }
                        } else {
                            // Known size models
                            if (seriesIdx === 0) {
                                knownSizeBaseSeries.data.push(dataPoint);
                            } else {
                                knownSizeInstructedSeries.data.push(dataPoint);
                            }
                        }
                    });
                });
            });

            // Get top 30% performing models across all time periods
            const getTop30PercentModels = (models, hasKnownSize) => {
                // Filter models based on whether they have known size
                const filteredModels = hasKnownSize ? 
                    models.filter(model => model.size !== null && model.size !== undefined) :
                    models.filter(model => model.size === null || model.size === undefined);
                
                // Sort by performance
                const sortedModels = [...filteredModels].sort((a, b) => b["pass@1"][score] - a["pass@1"][score]);
                
                // Take top 30%
                const cutoffIndex = Math.max(1, Math.floor(sortedModels.length * 0.3));
                const topModels = sortedModels.slice(0, cutoffIndex);
                
                // Get the minimum score in the top 30%
                const minScore = topModels.length > 0 ? topModels[topModels.length - 1]["pass@1"][score] : 0;
                
                // Return all models that meet or exceed this score
                return filteredModels.filter(model => model["pass@1"][score] >= minScore);
            };

            // Add trend lines for known size models
            const addTrendLine = (models, name, color, hasKnownSize) => {
                const topModels = getTop30PercentModels(models, hasKnownSize);
                
                // Group top models by date
                const trendData = [];
                dateLabels.forEach((dateGroup, idx) => {
                    const modelsInPeriod = topModels.filter(model => {
                        const date = new Date(model.date);
                        const yearPeriod = `${date.getFullYear()}-${String(Math.floor(date.getMonth() / 2)).padStart(1, '0')}`;
                        return yearPeriod === dateGroup;
                    });
                    
                    if (modelsInPeriod.length > 0) {
                        // Find the best model in this period
                        const bestModel = modelsInPeriod.reduce((best, current) => 
                            current["pass@1"][score] > best["pass@1"][score] ? current : best, modelsInPeriod[0]);
                        
                        trendData.push([idx, bestModel["pass@1"][score]]);
                    }
                });
                
                // Only add trend line if we have data points
                if (trendData.length > 0) {
                    timeOption.series.push({
                        name: name,
                        type: 'line',
                        smooth: true,
                        symbol: 'none',
                        sampling: 'average',
                        itemStyle: {
                            color: color
                        },
                        lineStyle: {
                            width: 2,
                            type: 'solid'
                        },
                        data: trendData
                    });
                }
            };

            // Add trend lines
            // Removed trend lines as requested

            // Add series to chart in specific order (unknown size first, then known size)
            timeOption.series = [
                unknownSizeBaseSeries,
                unknownSizeInstructedSeries,
                knownSizeBaseSeries,
                knownSizeInstructedSeries
            ];

            // Update legend
            timeOption.legend.data = [
                'base', 
                'instructed'
            ];

            // Highlight the best models in each time period
            dateLabels.forEach((dateGroup, idx) => {
                // Find best base model with known size
                const bestBaseModels = knownSizeBaseSeries.data
                    .filter(point => point.value[0] === idx)
                    .sort((a, b) => b.value[1] - a.value[1]);
                
                // Find best instructed model with known size
                const bestInstructedModels = knownSizeInstructedSeries.data
                    .filter(point => point.value[0] === idx)
                    .sort((a, b) => b.value[1] - a.value[1]);
                
                // Find best base model with unknown size
                const bestUnknownBaseModels = unknownSizeBaseSeries.data
                    .filter(point => point.value[0] === idx)
                    .sort((a, b) => b.value[1] - a.value[1]);
                
                // Find best instructed model with unknown size
                const bestUnknownInstructedModels = unknownSizeInstructedSeries.data
                    .filter(point => point.value[0] === idx)
                    .sort((a, b) => b.value[1] - a.value[1]);
                
                // Highlight best base model
                if (bestBaseModels.length > 0) {
                    const bestModel = bestBaseModels[0];
                    bestModel.itemStyle = {
                        color: "#91cc75",
                        opacity: 0.7
                    };
                    bestModel.label = {
                        show: true,
                        position: "top",
                        formatter: function(params) {
                            return cleanModelName(params.data.name);
                        },
                        color: "inherit",
                        opacity: 1.0  // Ensure label is fully opaque
                    };
                }
                
                // Highlight best instructed model
                if (bestInstructedModels.length > 0) {
                    const bestModel = bestInstructedModels[0];
                    bestModel.itemStyle = {
                        color: "#5470c6",
                        opacity: 0.7
                    };
                    bestModel.label = {
                        show: true,
                        position: "top",
                        formatter: function(params) {
                            return cleanModelName(params.data.name);
                        },
                        color: "inherit",
                        opacity: 1.0  // Ensure label is fully opaque
                    };
                }
                
                // Highlight best unknown base model in red
                if (bestUnknownBaseModels.length > 0) {
                    const bestModel = bestUnknownBaseModels[0];
                    bestModel.itemStyle = {
                        color: "#ff0000",  // Red color
                        opacity: 0.7
                    };
                    bestModel.label = {
                        show: true,
                        position: "top",
                        formatter: function(params) {
                            return cleanModelName(params.data.name);
                        },
                        color: "inherit",
                        opacity: 1.0  // Ensure label is fully opaque
                    };
                }
                
                // Highlight best unknown instructed model in red
                if (bestUnknownInstructedModels.length > 0) {
                    const bestModel = bestUnknownInstructedModels[0];
                    bestModel.itemStyle = {
                        color: "#ff0000",  // Red color
                        opacity: 0.7
                    };
                    bestModel.label = {
                        show: true,
                        position: "top",
                        formatter: function(params) {
                            return cleanModelName(params.data.name);
                        },
                        color: "inherit",
                        opacity: 1.0  // Ensure label is fully opaque
                    };
                }
            });

            // Set the chart option
            chart.setOption(timeOption, true);
        };

        const completeRadio = document.getElementById("Complete");
        const instructRadio = document.getElementById("Instruct");
        const averageRadio = document.getElementById("Average");

        completeRadio.addEventListener("click", function () {
            currentSplit = "complete";
            clearTable();
            displayTable(originTable, currentSplit);
            if (currentView === "size") {
                clearChart();
                displayChart(currentSplit, toggleUnknownSize.checked);
            } else {
                resetChartData();
                displayTimeChart(currentSplit, toggleUnknownSize.checked);
            }
        });

        instructRadio.addEventListener("click", function () {
            currentSplit = "instruct";
            clearTable();
            displayTable(originTable, currentSplit);
            if (currentView === "size") {
                clearChart();
                displayChart(currentSplit, toggleUnknownSize.checked);
            } else {
                resetChartData();
                displayTimeChart(currentSplit, toggleUnknownSize.checked);
            }
        });

        averageRadio.addEventListener("click", function () {
            currentSplit = "average";
            clearTable();
            displayTable(originTable, currentSplit);
            if (currentView === "size") {
                clearChart();
                displayChart(currentSplit, toggleUnknownSize.checked);
            } else {
                resetChartData();
                displayTimeChart(currentSplit, toggleUnknownSize.checked);
            }
        });

        toggleUnknownSize.addEventListener("change", function () {
            const score = completeRadio.checked ? "complete" : instructRadio.checked ? "instruct" : "average";
            if (currentView === "size") {
                clearChart();
                displayChart(score, toggleUnknownSize.checked);
            } else {
                resetChartData();
                displayTimeChart(score, toggleUnknownSize.checked);
            }
        });

        averageRadio.click();

        window.addEventListener("resize", () => {
            chart.resize();
        });
    </script>
</body>

</html>
